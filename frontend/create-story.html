<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/jpeg" href="/logo.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Story</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="/video-editor.css">
    <script src="/video-editor.js"></script>
</head>
<body>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            max-width: 100vw;
            overflow-x: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .back-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
        }

        .header-title {
            font-size: 18px;
            font-weight: 600;
        }

        .post-btn {
            background: #B39FFF;
            color: white;
            border: none;
            padding: 8px 24px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }

        .post-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Main Container */
        .create-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        /* Upload State */
        .upload-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 32px;
            padding: 20px;
        }

        .upload-state.hidden {
            display: none;
        }

        .upload-icon {
            font-size: 80px;
            color: #B39FFF;
        }

        .upload-text {
            text-align: center;
        }

        .upload-text h2 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .upload-text p {
            color: #999;
            font-size: 14px;
        }

        .upload-options {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .upload-btn {
            background: #2c2c2c;
            border: 2px solid #444;
            color: white;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }

        .upload-btn:hover {
            border-color: #B39FFF;
            background: #333;
        }

        .upload-btn i {
            font-size: 24px;
        }

        input[type="file"] {
            display: none;
        }

        /* Preview State */
        .preview-state {
            display: none;
            width: 100%;
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
        }

        .preview-state.active {
            display: flex;
        }

        #preview-media {
            max-width: 100%;
            max-height: 100vh;
            object-fit: contain;
            margin: 0 auto;
        }

        #preview-canvas {
            max-width: 100%;
            max-height: calc(100vh - 80px);
            display: none;
            margin: 0 auto;
            cursor: default;
            border-radius: 0;
        }

        #preview-canvas.active {
            display: block;
        }

        /* Desktop - Mobile Device Style */
        @media (min-width: 768px) {
            .create-container {
                background: #1a1a1a;
            }

            #preview-canvas {
                max-width: 390px;
                max-height: 844px;
                border-radius: 20px;
                box-shadow: 0 0 60px rgba(0, 0, 0, 0.9);
            }

            .preview-state {
                padding: 20px;
            }
        }

        /* Editing Tools */
        .edit-tools {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            backdrop-filter: blur(10px);
        }

        .tool-row {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 8px 0;
        }

        .tool-btn {
            background: #2c2c2c;
            border: 2px solid #444;
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 80px;
            transition: all 0.2s;
        }

        .tool-btn:hover,
        .tool-btn.active {
            border-color: #B39FFF;
            background: #333;
        }

        .tool-btn i {
            font-size: 20px;
        }

        .tool-btn span {
            font-size: 11px;
        }

        /* Text Editor */
        .text-editor {
            display: none;
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
        }

        .text-editor.active {
            display: block;
        }

        .text-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #444;
            border-radius: 8px;
            background: #2c2c2c;
            color: white;
            font-size: 16px;
            margin-bottom: 12px;
        }

        .color-picker-row {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 12px;
        }

        .color-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option.selected {
            border-color: white;
        }

        .size-slider {
            width: 100%;
            margin-bottom: 12px;
        }

        .text-style-options {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 12px;
        }

        .style-option-btn {
            width: 44px;
            height: 44px;
            background: #2c2c2c;
            border: 2px solid #444;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
        }

        .style-option-btn:hover {
            border-color: #B39FFF;
        }

        .style-option-btn.active {
            background: #B39FFF;
            border-color: #B39FFF;
        }

        .font-picker {
            margin-bottom: 12px;
        }

        .font-select {
            width: 100%;
            padding: 12px;
            background: #2c2c2c;
            border: 2px solid #444;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            cursor: pointer;
        }

        .font-select:focus {
            outline: none;
            border-color: #B39FFF;
        }

        .text-actions {
            display: flex;
            gap: 8px;
        }

        .text-actions button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }

        .text-actions .cancel-btn {
            background: #444;
            color: white;
        }

        .text-actions .add-btn {
            background: #B39FFF;
            color: white;
        }

        /* Canvas Text Elements */
        .canvas-text {
            position: absolute;
            color: white;
            font-weight: 600;
            cursor: move;
            user-select: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
        }

        /* Music Modal */
        .music-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        .music-modal.active {
            display: flex;
        }

        .music-modal-content {
            background: #1a1a1a;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .music-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
        }

        .music-header h3 {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
        }

        .close-music-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .close-music-btn:hover {
            background: #333;
        }

        .music-search {
            padding: 16px 20px;
            position: relative;
            border-bottom: 1px solid #333;
        }

        .music-search-input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            background: #2c2c2c;
            border: 2px solid #444;
            border-radius: 10px;
            color: #fff;
            font-size: 15px;
        }

        .music-search-input:focus {
            outline: none;
            border-color: #B39FFF;
        }

        .music-search i {
            position: absolute;
            right: 32px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 18px;
        }

        .music-categories {
            display: flex;
            gap: 8px;
            padding: 16px 20px;
            overflow-x: auto;
            border-bottom: 1px solid #333;
        }

        .category-btn {
            padding: 8px 16px;
            background: #2c2c2c;
            border: 2px solid #444;
            border-radius: 20px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .category-btn.active {
            background: #B39FFF;
            border-color: #B39FFF;
        }

        .music-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 20px;
        }

        .music-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #2c2c2c;
            border-radius: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .music-item:hover {
            background: #333;
        }

        .music-item.selected {
            border-color: #B39FFF;
            background: rgba(179, 159, 255, 0.1);
        }

        .music-item-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #B39FFF, #9d7fee);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .music-item-info {
            flex: 1;
        }

        .music-item-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .music-item-artist {
            font-size: 12px;
            color: #888;
        }

        .music-item-duration {
            font-size: 13px;
            color: #888;
        }

        .music-player {
            padding: 16px 20px;
            background: rgba(179, 159, 255, 0.1);
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .playing-track {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #B39FFF;
            font-weight: 600;
            font-size: 14px;
        }

        .playing-track i {
            font-size: 20px;
        }

        .remove-music-btn {
            background: #ff4444;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Filter Options */
        .filter-options {
            display: none;
            gap: 12px;
            overflow-x: auto;
            padding: 8px 0;
        }

        .filter-options.active {
            display: flex;
        }

        .filter-btn {
            min-width: 80px;
            padding: 8px 16px;
            background: #2c2c2c;
            border: 2px solid #444;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
        }

        .filter-btn.selected {
            border-color: #B39FFF;
        }

        /* Compression Info */
        .compression-info {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(179, 159, 255, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: none;
        }

        .compression-info.active {
            display: block;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
            color: #fff;
            max-width: 320px;
            padding: 32px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top-color: #B39FFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        .loading-content p {
            margin: 12px 0;
            font-size: 16px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .upload-progress-container {
            margin-top: 20px;
            width: 100%;
        }

        .upload-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .upload-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #B39FFF, #667eea);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(179, 159, 255, 0.5);
        }

        .upload-progress-text {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>

    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <button class="back-btn" onclick="goBack()">
                <i class="bi bi-x-lg"></i>
            </button>
            <span class="header-title">Create Story</span>
        </div>
        <button class="post-btn" id="post-btn" onclick="postStory()" disabled>Post</button>
    </div>

    <!-- Compression Info -->
    <div class="compression-info" id="compression-info"></div>

    <!-- Main Container -->
    <div class="create-container">
        <!-- Upload State -->
        <div class="upload-state" id="upload-state">
            <div class="upload-icon">
                <i class="bi bi-camera-fill"></i>
            </div>
            <div class="upload-text">
                <h2>Create Your Story</h2>
                <p>Share a photo or video with your friends</p>
            </div>
            <div class="upload-options">
                <label class="upload-btn">
                    <i class="bi bi-camera"></i>
                    <span>Take Photo</span>
                    <input type="file" id="camera-input" accept="image/*" capture="environment">
                </label>
                <label class="upload-btn">
                    <i class="bi bi-image"></i>
                    <span>Choose Photo</span>
                    <input type="file" id="photo-input" accept="image/*">
                </label>
                <label class="upload-btn">
                    <i class="bi bi-play-circle"></i>
                    <span>Choose Video</span>
                    <input type="file" id="video-input" accept="video/*">
                </label>
            </div>
        </div>

        <!-- Preview State -->
        <div class="preview-state" id="preview-state">
            <img id="preview-media" style="display: none;">
            <video id="preview-video" style="display: none;" controls></video>
            <canvas id="preview-canvas" width="1080" height="1920"></canvas>
        </div>
    </div>

    <!-- Editing Tools -->
    <div class="edit-tools" id="edit-tools" style="display: none;">
        <div class="tool-row">
            <button class="tool-btn" onclick="toggleTextEditor()">
                <i class="bi bi-fonts"></i>
                <span>Text</span>
            </button>
            <button class="tool-btn" onclick="toggleFilters()">
                <i class="bi bi-palette"></i>
                <span>Filters</span>
            </button>
            <button class="tool-btn" onclick="toggleMusicPicker()" id="music-btn">
                <i class="bi bi-music-note-beamed"></i>
                <span>Music</span>
            </button>
            <button class="tool-btn" onclick="cropMedia()">
                <i class="bi bi-crop"></i>
                <span>Crop</span>
            </button>
            <button class="tool-btn" onclick="rotateMedia()">
                <i class="bi bi-arrow-clockwise"></i>
                <span>Rotate</span>
            </button>
            <button class="tool-btn" onclick="adjustBrightness()">
                <i class="bi bi-brightness-high"></i>
                <span>Brightness</span>
            </button>
            <button class="tool-btn" onclick="openAdvancedVideoEditor()" id="advanced-edit-btn" style="display: none;">
                <i class="bi bi-sliders"></i>
                <span>Advanced Edit</span>
            </button>
        </div>

        <!-- Filter Options -->
        <div class="filter-options" id="filter-options">
            <button class="filter-btn selected" onclick="applyFilter('none')">Original</button>
            <button class="filter-btn" onclick="applyFilter('grayscale')">B&W</button>
            <button class="filter-btn" onclick="applyFilter('sepia')">Sepia</button>
            <button class="filter-btn" onclick="applyFilter('vintage')">Vintage</button>
            <button class="filter-btn" onclick="applyFilter('bright')">Bright</button>
            <button class="filter-btn" onclick="applyFilter('cool')">Cool</button>
            <button class="filter-btn" onclick="applyFilter('warm')">Warm</button>
        </div>
    </div>

    <!-- Text Editor -->
    <div class="text-editor" id="text-editor">
        <input type="text" class="text-input" id="text-input" placeholder="Add text...">
        <div class="color-picker-row">
            <div class="color-option selected" style="background: white;" onclick="selectColor('white')"></div>
            <div class="color-option" style="background: black;" onclick="selectColor('black')"></div>
            <div class="color-option" style="background: #B39FFF;" onclick="selectColor('#B39FFF')"></div>
            <div class="color-option" style="background: #ff4444;" onclick="selectColor('#ff4444')"></div>
            <div class="color-option" style="background: #44ff44;" onclick="selectColor('#44ff44')"></div>
            <div class="color-option" style="background: #ffff44;" onclick="selectColor('#ffff44')"></div>
        </div>
        <input type="range" class="size-slider" id="size-slider" min="16" max="72" value="32">

        <div class="text-style-options">
            <button class="style-option-btn" id="bold-btn" onclick="toggleTextStyle('bold')">
                <i class="bi bi-type-bold"></i>
            </button>
            <button class="style-option-btn" id="italic-btn" onclick="toggleTextStyle('italic')">
                <i class="bi bi-type-italic"></i>
            </button>
        </div>

        <div style="margin: 12px 0;">
            <label style="font-size: 12px; color: #888; margin-bottom: 8px; display: block; text-transform: uppercase; letter-spacing: 1px;">Text Style</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div onclick="selectTextStyle('outline')" class="text-bg-style-option" data-style="outline" style="padding: 10px; border: 2px solid #B39FFF; border-radius: 10px; cursor: pointer; text-align: center; background: #222;">
                    <span style="font-weight: 600; font-size: 13px; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;">Outline</span>
                </div>
                <div onclick="selectTextStyle('solid')" class="text-bg-style-option" data-style="solid" style="padding: 10px; border: 2px solid #333; border-radius: 10px; cursor: pointer; text-align: center; background: #222;">
                    <span style="background: white; color: black; padding: 3px 10px; border-radius: 5px; font-weight: 600; font-size: 13px;">Solid</span>
                </div>
                <div onclick="selectTextStyle('rounded')" class="text-bg-style-option" data-style="rounded" style="padding: 10px; border: 2px solid #333; border-radius: 10px; cursor: pointer; text-align: center; background: #222;">
                    <span style="background: white; color: black; padding: 5px 14px; border-radius: 16px; font-weight: 600; font-size: 13px;">Rounded</span>
                </div>
                <div onclick="selectTextStyle('semi')" class="text-bg-style-option" data-style="semi" style="padding: 10px; border: 2px solid #333; border-radius: 10px; cursor: pointer; text-align: center; background: #222;">
                    <span style="background: rgba(255,255,255,0.3); padding: 3px 10px; border-radius: 5px; font-weight: 600; font-size: 13px;">Semi</span>
                </div>
            </div>
        </div>

        <div class="font-picker">
            <select id="font-select" class="font-select">
                <option value="Arial">Arial</option>
                <option value="Impact">Impact</option>
                <option value="Comic Sans MS">Comic Sans</option>
                <option value="Georgia">Georgia</option>
                <option value="Courier New">Courier New</option>
                <option value="Brush Script MT">Brush Script</option>
            </select>
        </div>

        <div class="text-actions">
            <button class="cancel-btn" onclick="closeTextEditor()">Cancel</button>
            <button class="add-btn" onclick="addText()">Add Text</button>
        </div>
    </div>

    <!-- Music Picker Modal -->
    <div class="music-modal" id="music-modal">
        <div class="music-modal-content">
            <div class="music-header">
                <h3>Add Music</h3>
                <button class="close-music-btn" onclick="closeMusicPicker()">
                    <i class="bi bi-x"></i>
                </button>
            </div>

            <div class="music-search">
                <input type="text" id="music-search-input" class="music-search-input" placeholder="Search music..." oninput="searchMusic(this.value)">
                <i class="bi bi-search"></i>
            </div>

            <div class="music-categories">
                <button class="category-btn active" onclick="filterByCategory('all')">All</button>
                <button class="category-btn" onclick="filterByCategory('upbeat')">Upbeat</button>
                <button class="category-btn" onclick="filterByCategory('chill')">Chill</button>
                <button class="category-btn" onclick="filterByCategory('cinematic')">Cinematic</button>
                <button class="category-btn" onclick="filterByCategory('electronic')">Electronic</button>
            </div>

            <div class="music-list" id="music-list">
                <!-- Music tracks will be populated here -->
            </div>

            <div class="music-player" id="music-player" style="display: none;">
                <div class="playing-track">
                    <i class="bi bi-music-note-beamed"></i>
                    <span id="playing-track-name">Track Name</span>
                </div>
                <button class="remove-music-btn" onclick="removeMusic()">
                    <i class="bi bi-trash"></i> Remove
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p id="loading-status">Preparing your story...</p>
            <div class="upload-progress-container" id="upload-progress-container" style="display: none;">
                <div class="upload-progress-bar">
                    <div class="upload-progress-fill" id="upload-progress-fill"></div>
                </div>
                <div class="upload-progress-text">
                    <span id="upload-progress-percent">0%</span>
                    <span id="upload-progress-speed">...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedFile = null;
        let isVideo = false;
        let canvas, ctx;
        let currentFilter = 'none';
        let rotation = 0;
        let brightness = 1;
        let textElements = [];
        let selectedTextColor = 'white';
        let selectedTextSize = 32;
        let selectedTextFont = 'Arial';
        let textStyleBold = false;
        let textStyleItalic = false;
        let textStyleOutline = false;
        let selectedTextBgStyle = 'outline'; // outline, solid, rounded, semi
        let originalImage = null;
        let selectedMusic = null;
        let currentCategory = 'all';
        let isDragging = false;
        let draggedTextIndex = -1;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // Pinch-to-zoom variables
        let isPinching = false;
        let initialPinchDistance = 0;
        let initialTextSize = 0;
        let pinchTextIndex = -1;

        // Royalty-free music library (placeholder - can be replaced with real tracks)
        const musicLibrary = [
            { id: 1, title: 'Upbeat Summer', artist: 'Free Music', duration: '2:15', category: 'upbeat', url: '/music/upbeat-summer.mp3' },
            { id: 2, title: 'Chill Vibes', artist: 'Free Music', duration: '3:20', category: 'chill', url: '/music/chill-vibes.mp3' },
            { id: 3, title: 'Epic Journey', artist: 'Free Music', duration: '2:45', category: 'cinematic', url: '/music/epic-journey.mp3' },
            { id: 4, title: 'Electronic Dreams', artist: 'Free Music', duration: '3:00', category: 'electronic', url: '/music/electronic-dreams.mp3' },
            { id: 5, title: 'Happy Day', artist: 'Free Music', duration: '2:30', category: 'upbeat', url: '/music/happy-day.mp3' },
            { id: 6, title: 'Calm Waters', artist: 'Free Music', duration: '3:45', category: 'chill', url: '/music/calm-waters.mp3' },
            { id: 7, title: 'Adventure Awaits', artist: 'Free Music', duration: '2:55', category: 'cinematic', url: '/music/adventure-awaits.mp3' },
            { id: 8, title: 'Neon Lights', artist: 'Free Music', duration: '3:10', category: 'electronic', url: '/music/neon-lights.mp3' },
            { id: 9, title: 'Feel Good', artist: 'Free Music', duration: '2:40', category: 'upbeat', url: '/music/feel-good.mp3' },
            { id: 10, title: 'Sunset Chill', artist: 'Free Music', duration: '4:00', category: 'chill', url: '/music/sunset-chill.mp3' },
            { id: 11, title: 'Cinematic Rise', artist: 'Free Music', duration: '3:15', category: 'cinematic', url: '/music/cinematic-rise.mp3' },
            { id: 12, title: 'Digital Wave', artist: 'Free Music', duration: '2:50', category: 'electronic', url: '/music/digital-wave.mp3' }
        ];

        // Initialize
        document.getElementById('camera-input').addEventListener('change', handleFileSelect);
        document.getElementById('photo-input').addEventListener('change', handleFileSelect);
        document.getElementById('video-input').addEventListener('change', handleFileSelect);

        // Dragging functionality for text elements
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = evt.touches[0];

            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        function isPointInText(x, y, textElement) {
            if (!ctx) return false;

            let fontStyle = '';
            if (textElement.italic) fontStyle += 'italic ';
            if (textElement.bold) fontStyle += 'bold ';

            ctx.font = `${fontStyle}${textElement.size}px ${textElement.font || 'Arial'}`;
            const textMetrics = ctx.measureText(textElement.content);
            const textWidth = textMetrics.width;
            const textHeight = textElement.size * 1.5; // Increase hit area

            // Expand hit area for easier touching
            const padding = 20;

            return (
                x >= textElement.x - textWidth / 2 - padding &&
                x <= textElement.x + textWidth / 2 + padding &&
                y >= textElement.y - textHeight / 2 - padding &&
                y <= textElement.y + textHeight / 2 + padding
            );
        }

        function handleCanvasMouseDown(evt) {
            if (!canvas) return;

            const pos = getMousePos(canvas, evt);
            console.log('Mouse down at:', pos.x, pos.y);

            // Check if clicking on any text element (check in reverse order for top-most)
            for (let i = textElements.length - 1; i >= 0; i--) {
                console.log('Checking text', i, 'at', textElements[i].x, textElements[i].y);
                if (isPointInText(pos.x, pos.y, textElements[i])) {
                    isDragging = true;
                    draggedTextIndex = i;
                    dragOffsetX = pos.x - textElements[i].x;
                    dragOffsetY = pos.y - textElements[i].y;
                    canvas.style.cursor = 'grabbing';
                    console.log('Started dragging text', i);
                    break;
                }
            }
        }

        function handleCanvasMouseMove(evt) {
            if (!canvas) return;

            const pos = getMousePos(canvas, evt);

            if (isDragging && draggedTextIndex >= 0) {
                // Update text position
                textElements[draggedTextIndex].x = pos.x - dragOffsetX;
                textElements[draggedTextIndex].y = pos.y - dragOffsetY;
                console.log('Dragging text to:', textElements[draggedTextIndex].x, textElements[draggedTextIndex].y);
                drawCanvas();
            } else {
                // Change cursor if hovering over text
                let hovering = false;
                for (let i = textElements.length - 1; i >= 0; i--) {
                    if (isPointInText(pos.x, pos.y, textElements[i])) {
                        hovering = true;
                        break;
                    }
                }
                canvas.style.cursor = hovering ? 'grab' : 'default';
            }
        }

        function handleCanvasMouseUp() {
            isDragging = false;
            draggedTextIndex = -1;
            if (canvas) canvas.style.cursor = 'default';
        }

        // Pinch-to-zoom helper functions
        function getTouchDistance(touch1, touch2, canvas) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x1 = (touch1.clientX - rect.left) * scaleX;
            const y1 = (touch1.clientY - rect.top) * scaleY;
            const x2 = (touch2.clientX - rect.left) * scaleX;
            const y2 = (touch2.clientY - rect.top) * scaleY;

            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function getTouchMidpoint(touch1, touch2, canvas) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x1 = (touch1.clientX - rect.left) * scaleX;
            const y1 = (touch1.clientY - rect.top) * scaleY;
            const x2 = (touch2.clientX - rect.left) * scaleX;
            const y2 = (touch2.clientY - rect.top) * scaleY;

            return {
                x: (x1 + x2) / 2,
                y: (y1 + y2) / 2
            };
        }

        // Touch event handlers
        function handleCanvasTouchStart(evt) {
            evt.preventDefault();
            if (!canvas) return;

            // Check if this is a pinch gesture (2 fingers)
            if (evt.touches.length === 2) {
                // Get midpoint of two fingers
                const midpoint = getTouchMidpoint(evt.touches[0], evt.touches[1], canvas);

                // Check if midpoint is on any text
                for (let i = textElements.length - 1; i >= 0; i--) {
                    if (isPointInText(midpoint.x, midpoint.y, textElements[i])) {
                        isPinching = true;
                        pinchTextIndex = i;
                        initialPinchDistance = getTouchDistance(evt.touches[0], evt.touches[1], canvas);
                        initialTextSize = textElements[i].size;
                        console.log('Pinch started on text', i, 'initial distance:', initialPinchDistance);
                        return; // Don't start dragging if pinching
                    }
                }
            }

            // Single finger - check for drag
            if (evt.touches.length === 1) {
                const pos = getTouchPos(canvas, evt);
                console.log('Touch start at:', pos.x, pos.y);
                console.log('Text elements:', textElements.length);

                for (let i = textElements.length - 1; i >= 0; i--) {
                    if (isPointInText(pos.x, pos.y, textElements[i])) {
                        isDragging = true;
                        draggedTextIndex = i;
                        dragOffsetX = pos.x - textElements[i].x;
                        dragOffsetY = pos.y - textElements[i].y;
                        console.log('Started dragging text', i);
                        break;
                    }
                }
            }
        }

        function handleCanvasTouchMove(evt) {
            evt.preventDefault();
            if (!canvas) return;

            // Handle pinch-to-zoom
            if (isPinching && evt.touches.length === 2 && pinchTextIndex >= 0) {
                const currentDistance = getTouchDistance(evt.touches[0], evt.touches[1], canvas);
                const scale = currentDistance / initialPinchDistance;

                // Calculate new size (with limits)
                let newSize = initialTextSize * scale;
                newSize = Math.max(16, Math.min(200, newSize)); // Clamp between 16 and 200

                textElements[pinchTextIndex].size = Math.round(newSize);
                drawCanvas();
                return;
            }

            // Handle drag
            if (isDragging && draggedTextIndex >= 0 && evt.touches.length === 1) {
                const pos = getTouchPos(canvas, evt);
                textElements[draggedTextIndex].x = pos.x - dragOffsetX;
                textElements[draggedTextIndex].y = pos.y - dragOffsetY;
                drawCanvas();
            }
        }

        function handleCanvasTouchEnd(evt) {
            evt.preventDefault();

            // Reset pinch state
            if (isPinching) {
                isPinching = false;
                pinchTextIndex = -1;
                initialPinchDistance = 0;
                initialTextSize = 0;
                console.log('Pinch ended');
                return;
            }

            isDragging = false;
            draggedTextIndex = -1;
        }

        // Add event listeners when canvas is ready
        let canvasEventsInitialized = false;
        function initCanvasEvents() {
            if (!canvas || canvasEventsInitialized) return;
            canvasEventsInitialized = true;

            // Mouse events
            canvas.addEventListener('mousedown', handleCanvasMouseDown, false);
            canvas.addEventListener('mousemove', handleCanvasMouseMove, false);
            canvas.addEventListener('mouseup', handleCanvasMouseUp, false);
            canvas.addEventListener('mouseleave', handleCanvasMouseUp, false);

            // Touch events with explicit passive: false
            canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false });

            console.log('Canvas events initialized');
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            selectedFile = file;
            isVideo = file.type.startsWith('video/');

            // Show compression info
            showCompressionInfo(file);

            // Load preview
            loadPreview(file);
        }

        function showCompressionInfo(file) {
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            const info = document.getElementById('compression-info');
            info.textContent = `Original: ${sizeMB}MB - Will be compressed`;
            info.classList.add('active');

            setTimeout(() => {
                info.classList.remove('active');
            }, 3000);
        }

        function loadPreview(file) {
            document.getElementById('upload-state').classList.add('hidden');
            document.getElementById('preview-state').classList.add('active');
            document.getElementById('edit-tools').style.display = 'block';
            document.getElementById('post-btn').disabled = false;

            const reader = new FileReader();
            reader.onload = (e) => {
                if (isVideo) {
                    const video = document.getElementById('preview-video');
                    video.src = e.target.result;
                    video.style.display = 'block';
                    document.getElementById('preview-canvas').style.display = 'none';

                    // Show Advanced Edit button for videos
                    const advancedEditBtn = document.getElementById('advanced-edit-btn');
                    if (advancedEditBtn) {
                        advancedEditBtn.style.display = 'flex';
                        console.log('Advanced Edit button shown for video');
                    } else {
                        console.error('Advanced Edit button not found!');
                    }
                } else {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        setupCanvas(img);
                    };
                    img.src = e.target.result;

                    // Hide Advanced Edit button for images
                    const advancedEditBtn = document.getElementById('advanced-edit-btn');
                    if (advancedEditBtn) {
                        advancedEditBtn.style.display = 'none';
                        console.log('Advanced Edit button hidden for image');
                    }
                }
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            canvas = document.getElementById('preview-canvas');
            ctx = canvas.getContext('2d');

            // Fixed 9:16 aspect ratio (like TikTok/Instagram Stories)
            const targetWidth = 1080;
            const targetHeight = 1920;

            canvas.width = targetWidth;
            canvas.height = targetHeight;

            console.log('Canvas set to 9:16 ratio:', canvas.width, 'x', canvas.height);

            canvas.classList.add('active');

            // Reset event initialization flag
            canvasEventsInitialized = false;

            drawCanvas();

            // Initialize dragging functionality after a short delay
            setTimeout(() => {
                initCanvasEvents();
                console.log('Canvas ready for text dragging');
            }, 100);
        }

        function drawCanvas() {
            if (!originalImage || !ctx) return;

            ctx.save();

            // Fill with dark gray background (letterboxing)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate scaling to fit image with letterboxing
            const imgAspect = originalImage.width / originalImage.height;
            const canvasAspect = canvas.width / canvas.height;

            let drawWidth, drawHeight, offsetX, offsetY;

            if (imgAspect > canvasAspect) {
                // Image is wider - fit to width
                drawWidth = canvas.width;
                drawHeight = canvas.width / imgAspect;
                offsetX = 0;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                // Image is taller - fit to height
                drawHeight = canvas.height;
                drawWidth = canvas.height * imgAspect;
                offsetX = (canvas.width - drawWidth) / 2;
                offsetY = 0;
            }

            // Apply transformations
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            // Apply filters
            ctx.filter = getFilterString();
            ctx.drawImage(originalImage, offsetX, offsetY, drawWidth, drawHeight);

            ctx.restore();

            // Draw text elements with styles
            textElements.forEach(text => {
                let fontStyle = '';
                if (text.italic) fontStyle += 'italic ';
                if (text.bold) fontStyle += 'bold ';

                ctx.font = `${fontStyle}${text.size}px ${text.font || 'Arial'}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const style = text.style || (text.outline ? 'outline' : 'outline');
                const metrics = ctx.measureText(text.content);
                const textWidth = metrics.width;
                const textHeight = text.size;

                if (style === 'outline' || text.outline) {
                    // Classic outlined text
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.strokeText(text.content, text.x, text.y);
                    ctx.fillStyle = text.color;
                    ctx.fillText(text.content, text.x, text.y);
                } else if (style === 'solid') {
                    // Solid rectangular background
                    const padding = 8;
                    ctx.fillStyle = text.color === 'white' || text.color === '#fff' ? '#000' : '#fff';
                    ctx.fillRect(
                        text.x - textWidth / 2 - padding,
                        text.y - textHeight / 2 - padding,
                        textWidth + padding * 2,
                        textHeight + padding * 2
                    );
                    ctx.fillStyle = text.color === 'white' || text.color === '#fff' ? '#fff' : '#000';
                    ctx.fillText(text.content, text.x, text.y);
                } else if (style === 'rounded') {
                    // Rounded pill background
                    const padding = 12;
                    const radius = textHeight / 2 + padding;
                    ctx.fillStyle = text.color === 'white' || text.color === '#fff' ? '#000' : '#fff';
                    ctx.beginPath();
                    ctx.roundRect(
                        text.x - textWidth / 2 - padding,
                        text.y - textHeight / 2 - padding,
                        textWidth + padding * 2,
                        textHeight + padding * 2,
                        radius
                    );
                    ctx.fill();
                    ctx.fillStyle = text.color === 'white' || text.color === '#fff' ? '#fff' : '#000';
                    ctx.fillText(text.content, text.x, text.y);
                } else if (style === 'semi') {
                    // Semi-transparent background
                    const padding = 8;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(
                        text.x - textWidth / 2 - padding,
                        text.y - textHeight / 2 - padding,
                        textWidth + padding * 2,
                        textHeight + padding * 2
                    );
                    ctx.fillStyle = text.color;
                    ctx.fillText(text.content, text.x, text.y);
                }

                // Add shadow for better visibility
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
            });

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function getFilterString() {
            let filter = `brightness(${brightness}) `;

            switch(currentFilter) {
                case 'grayscale':
                    filter += 'grayscale(100%)';
                    break;
                case 'sepia':
                    filter += 'sepia(100%)';
                    break;
                case 'vintage':
                    filter += 'sepia(50%) contrast(1.2) brightness(1.1)';
                    break;
                case 'bright':
                    filter += 'brightness(1.3) contrast(1.1)';
                    break;
                case 'cool':
                    filter += 'hue-rotate(180deg) saturate(1.2)';
                    break;
                case 'warm':
                    filter += 'sepia(30%) saturate(1.4)';
                    break;
                default:
                    break;
            }

            return filter;
        }

        // Text Editor Functions
        function toggleTextEditor() {
            const editor = document.getElementById('text-editor');
            editor.classList.toggle('active');
        }

        function closeTextEditor() {
            document.getElementById('text-editor').classList.remove('active');
            document.getElementById('text-input').value = '';
        }

        function selectColor(color) {
            selectedTextColor = color;
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        document.getElementById('size-slider').addEventListener('input', (e) => {
            selectedTextSize = parseInt(e.target.value);
        });

        function addText() {
            const text = document.getElementById('text-input').value.trim();
            if (!text) return;

            textElements.push({
                content: text,
                color: selectedTextColor,
                size: selectedTextSize,
                font: selectedTextFont,
                bold: textStyleBold,
                italic: textStyleItalic,
                outline: textStyleOutline,
                style: selectedTextBgStyle,
                x: canvas.width / 2,
                y: canvas.height / 2
            });

            drawCanvas();
            closeTextEditor();
            document.getElementById('text-input').value = '';
        }

        function selectTextStyle(style) {
            selectedTextBgStyle = style;
            document.querySelectorAll('.text-bg-style-option').forEach(opt => {
                opt.style.borderColor = opt.getAttribute('data-style') === style ? '#B39FFF' : '#333';
            });
        }

        function toggleTextStyle(style) {
            const btn = document.getElementById(`${style}-btn`);

            if (style === 'bold') {
                textStyleBold = !textStyleBold;
                btn.classList.toggle('active', textStyleBold);
            } else if (style === 'italic') {
                textStyleItalic = !textStyleItalic;
                btn.classList.toggle('active', textStyleItalic);
            } else if (style === 'outline') {
                textStyleOutline = !textStyleOutline;
                btn.classList.toggle('active', textStyleOutline);
            }
        }

        // Update font selection
        document.addEventListener('DOMContentLoaded', () => {
            const fontSelect = document.getElementById('font-select');
            if (fontSelect) {
                fontSelect.addEventListener('change', (e) => {
                    selectedTextFont = e.target.value;
                });
            }
        });

        // Filter Functions
        function toggleFilters() {
            const filters = document.getElementById('filter-options');
            filters.classList.toggle('active');
        }

        function applyFilter(filter) {
            currentFilter = filter;
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
            drawCanvas();
        }

        // Transform Functions
        function rotateMedia() {
            rotation = (rotation + 90) % 360;
            drawCanvas();
        }

        function adjustBrightness() {
            brightness = brightness >= 1.5 ? 0.5 : brightness + 0.25;
            drawCanvas();
        }

        function cropMedia() {
            alert('Crop feature coming soon!');
        }

        // Compress and Upload
        async function compressImage(file, maxSizeMB = 10) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Resize if too large
                        let width = img.width;
                        let height = img.height;
                        const maxDim = 1920;

                        if (width > maxDim || height > maxDim) {
                            if (width > height) {
                                height = (height / width) * maxDim;
                                width = maxDim;
                            } else {
                                width = (width / height) * maxDim;
                                height = maxDim;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // Compress
                        let quality = 0.8;
                        canvas.toBlob((blob) => {
                            const sizeMB = blob.size / 1024 / 1024;
                            if (sizeMB > maxSizeMB && quality > 0.3) {
                                quality -= 0.1;
                                canvas.toBlob(resolve, 'image/jpeg', quality);
                            } else {
                                resolve(blob);
                            }
                        }, 'image/jpeg', quality);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        async function compressVideo(file, maxSizeMB = 100) {
            // For videos, we'll just ensure they're under max size
            // Full video compression requires ffmpeg or similar
            if (file.size / 1024 / 1024 > maxSizeMB) {
                alert(`Video is too large. Please select a smaller video (under ${maxSizeMB}MB).`);
                return null;
            }
            return file;
        }

        async function postStory() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingStatus = document.getElementById('loading-status');
            const progressContainer = document.getElementById('upload-progress-container');
            const progressFill = document.getElementById('upload-progress-fill');
            const progressPercent = document.getElementById('upload-progress-percent');
            const progressSpeed = document.getElementById('upload-progress-speed');

            loadingOverlay.classList.add('active');
            loadingStatus.textContent = 'Preparing your story...';

            try {
                // Get user info
                const userData = JSON.parse(localStorage.getItem('user') || '{}');
                const userId = userData.id;

                if (!userId) {
                    alert('Please login first');
                    window.location.href = '/';
                    return;
                }

                let finalBlob;

                let fileExtension = 'mp4';
                if (isVideo) {
                    // Check if we have a rendered video with edits
                    if (window.renderedVideoFile) {
                        loadingStatus.textContent = 'Preparing edited video...';
                        finalBlob = window.renderedVideoFile;
                        fileExtension = 'webm'; // Rendered videos are WebM format
                        console.log('Using rendered video with edits');
                        console.log('Rendered video size:', (finalBlob.size / (1024 * 1024)).toFixed(2), 'MB');
                    } else {
                        loadingStatus.textContent = 'Compressing video...';
                        finalBlob = await compressVideo(selectedFile);
                        if (!finalBlob) {
                            loadingOverlay.classList.remove('active');
                            return;
                        }
                    }
                } else {
                    loadingStatus.textContent = 'Processing image...';
                    // Get the canvas with all edits
                    finalBlob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.8);
                    });
                }

                // Check file size (warn if > 100MB)
                const fileSizeMB = finalBlob.size / (1024 * 1024);
                console.log('Upload file size:', fileSizeMB.toFixed(2), 'MB');

                if (fileSizeMB > 100) {
                    const proceed = confirm(`Video is large (${fileSizeMB.toFixed(1)}MB). Upload may take a while or fail. Continue?`);
                    if (!proceed) {
                        loadingOverlay.classList.remove('active');
                        return;
                    }
                }

                // Upload to server with story metadata
                const formData = new FormData();
                const timestamp = Date.now();
                const fileName = isVideo ? `story_${timestamp}.${fileExtension}` : `story_${timestamp}.jpg`;
                formData.append('file', finalBlob, fileName);
                console.log('Uploading as:', fileName);
                formData.append('user_id', userId);
                formData.append('media_type', isVideo ? 'video' : 'image');

                // Add caption if text was added
                if (textElements.length > 0) {
                    const caption = textElements.map(t => t.content).join(' ');
                    formData.append('caption', caption);
                }

                // Use XMLHttpRequest for upload progress
                loadingStatus.textContent = 'Uploading story...';
                progressContainer.style.display = 'block';

                const uploadStartTime = Date.now();
                let lastLoaded = 0;
                let lastTime = uploadStartTime;

                await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();

                    // Set timeout (10 minutes for large files)
                    xhr.timeout = 600000;

                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            const percent = Math.round((e.loaded / e.total) * 100);
                            progressFill.style.width = percent + '%';
                            progressPercent.textContent = percent + '%';

                            // Calculate speed
                            const now = Date.now();
                            const timeDiff = (now - lastTime) / 1000; // seconds
                            const bytesDiff = e.loaded - lastLoaded;

                            if (timeDiff > 0.5) { // Update speed every 0.5s
                                const speedMBps = (bytesDiff / timeDiff / (1024 * 1024)).toFixed(2);
                                progressSpeed.textContent = speedMBps + ' MB/s';
                                lastLoaded = e.loaded;
                                lastTime = now;
                            }
                        }
                    });

                    xhr.addEventListener('load', () => {
                        console.log('XHR load event, status:', xhr.status);
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                const response = JSON.parse(xhr.responseText);
                                console.log('Upload successful:', response);
                                resolve(response);
                            } catch (e) {
                                console.error('Failed to parse response:', xhr.responseText);
                                reject(new Error('Invalid server response'));
                            }
                        } else {
                            console.error('Upload failed with status:', xhr.status, xhr.statusText);
                            console.error('Response:', xhr.responseText);
                            reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));
                        }
                    });

                    xhr.addEventListener('error', (e) => {
                        console.error('XHR error event:', e);
                        console.error('XHR state:', xhr.readyState, 'Status:', xhr.status);
                        reject(new Error('Network error - check your internet connection'));
                    });

                    xhr.addEventListener('timeout', () => {
                        console.error('XHR timeout after', xhr.timeout, 'ms');
                        reject(new Error('Upload timeout - file may be too large'));
                    });

                    xhr.addEventListener('abort', () => {
                        console.error('XHR aborted');
                        reject(new Error('Upload cancelled'));
                    });

                    console.log('Starting XHR upload to /api/stories/create');
                    xhr.open('POST', '/api/stories/create');
                    xhr.send(formData);
                });

                // Success
                console.log('Story created successfully');
                loadingStatus.textContent = ' Story posted!';

                setTimeout(() => {
                    window.location.href = '/stories.html?refresh=' + Date.now();
                }, 500);

            } catch (error) {
                console.error('Error posting story:', error);
                alert('Failed to post story. Please try again.');
            } finally {
                setTimeout(() => {
                    loadingOverlay.classList.remove('active');
                    progressContainer.style.display = 'none';
                    progressFill.style.width = '0%';
                }, 2000);
            }
        }

        // Music picker functions
        function toggleMusicPicker() {
            const modal = document.getElementById('music-modal');
            modal.classList.add('active');
            renderMusicList();
        }

        function closeMusicPicker() {
            const modal = document.getElementById('music-modal');
            modal.classList.remove('active');
        }

        function renderMusicList(filteredTracks = null) {
            const tracks = filteredTracks || musicLibrary;
            const musicList = document.getElementById('music-list');

            musicList.innerHTML = tracks.map(track => `
                <div class="music-item ${selectedMusic && selectedMusic.id === track.id ? 'selected' : ''}"
                     onclick="selectMusic(${track.id})">
                    <div class="music-item-icon">
                        <i class="bi bi-music-note"></i>
                    </div>
                    <div class="music-item-info">
                        <div class="music-item-title">${track.title}</div>
                        <div class="music-item-artist">${track.artist}</div>
                    </div>
                    <div class="music-item-duration">${track.duration}</div>
                </div>
            `).join('');
        }

        function selectMusic(trackId) {
            selectedMusic = musicLibrary.find(t => t.id === trackId);

            // Update UI
            renderMusicList();

            // Show music player indicator
            const musicPlayer = document.getElementById('music-player');
            const trackNameEl = document.getElementById('playing-track-name');

            musicPlayer.style.display = 'flex';
            trackNameEl.textContent = selectedMusic.title;

            // Update music button to show selected state
            const musicBtn = document.getElementById('music-btn');
            musicBtn.classList.add('active');

            // Close modal after selection
            setTimeout(() => closeMusicPicker(), 500);
        }

        function removeMusic() {
            selectedMusic = null;
            document.getElementById('music-player').style.display = 'none';
            document.getElementById('music-btn').classList.remove('active');
        }

        function filterByCategory(category) {
            currentCategory = category;

            // Update category button states
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Filter tracks
            const filteredTracks = category === 'all'
                ? musicLibrary
                : musicLibrary.filter(t => t.category === category);

            renderMusicList(filteredTracks);
        }

        function searchMusic(query) {
            const searchQuery = query.toLowerCase().trim();

            if (!searchQuery) {
                // Show all tracks for current category
                const filteredTracks = currentCategory === 'all'
                    ? musicLibrary
                    : musicLibrary.filter(t => t.category === currentCategory);
                renderMusicList(filteredTracks);
                return;
            }

            // Search in title and artist
            const searchResults = musicLibrary.filter(track =>
                track.title.toLowerCase().includes(searchQuery) ||
                track.artist.toLowerCase().includes(searchQuery)
            );

            renderMusicList(searchResults);
        }

        function goBack() {
            if (confirm('Discard this story?')) {
                window.location.href = '/stories';
            }
        }

        // Video Editor Integration
        function openAdvancedVideoEditor() {
            if (!isVideo) {
                alert('Advanced editor is only available for videos');
                return;
            }

            // Get the video source
            const video = document.getElementById('preview-video');
            if (!video || !video.src) {
                alert('Please upload a video first');
                return;
            }

            // Open the video editor with current text elements
            openVideoEditor(video.src, textElements);
        }

        // Server-side rendering (10-100x faster!)
        async function renderEditedVideoServer() {
            console.log('renderEditedVideoServer() called - using FFmpeg');

            const loadingStatus = document.getElementById('loading-status');
            if (!loadingStatus) {
                console.error('loading-status element not found!');
            } else {
                loadingStatus.textContent = 'Uploading video for rendering...';
            }

            try {
                // Get user ID
                const userData = JSON.parse(localStorage.getItem('user') || '{}');
                const userId = userData.id;

                if (!userId) {
                    throw new Error('User not logged in');
                }

                // Prepare FormData with all render data
                const formData = new FormData();
                formData.append('user_id', userId);

                // Add original video
                formData.append('video', selectedFile);

                // Add text elements
                if (textElements.length > 0) {
                    formData.append('text_elements', JSON.stringify(textElements));
                }

                // Add video clips info
                if (videoEditor && videoEditor.videoTracks.length > 0) {
                    formData.append('video_clips', JSON.stringify(videoEditor.videoTracks));

                    // Add additional video files
                    for (let track of videoEditor.videoTracks) {
                        if (track.type !== 'main' && track.file) {
                            formData.append(`video_clip_${track.id}`, track.file);
                        }
                    }
                }

                // Add audio tracks
                if (videoEditor && videoEditor.audioTracks.length > 0) {
                    formData.append('audio_tracks', JSON.stringify(videoEditor.audioTracks));

                    // Add audio files
                    for (let track of videoEditor.audioTracks) {
                        if (track.file) {
                            formData.append(`audio_${track.id}`, track.file);
                        }
                    }
                }

                // Add speed
                if (videoEditor && videoEditor.speed !== 1.0) {
                    formData.append('speed', videoEditor.speed.toString());
                }

                console.log('Sending render request to server...');
                loadingStatus.textContent = 'Server is rendering your video...';

                // Send to server
                const response = await fetch('/api/stories/render', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(`Render failed: ${error}`);
                }

                const result = await response.json();
                console.log(' Server render complete:', result);
                console.log('Render time:', result.render_time_seconds, 'seconds');

                loadingStatus.textContent = 'Downloading rendered video...';

                // Download rendered video
                const videoResponse = await fetch(result.video_url);
                const blob = await videoResponse.blob();

                console.log(' Downloaded rendered video:', blob.size, 'bytes');

                return blob;

            } catch (error) {
                console.error('Server rendering failed:', error);
                throw error;
            }
        }

        // Browser-based rendering (slower but works offline) - FALLBACK
        async function renderEditedVideo() {
            console.log('renderEditedVideo() called');

            if (!videoEditor) {
                console.error('videoEditor not found!');
                return null;
            }

            const loadingStatus = document.getElementById('loading-status');
            if (!loadingStatus) {
                console.error('loading-status element not found!');
            } else {
                loadingStatus.textContent = 'Rendering your edits...';
            }

            try {
                const canvas = document.getElementById('editor-canvas');
                if (!canvas) {
                    throw new Error('Editor canvas not found');
                }

                console.log('Canvas found:', canvas.width, 'x', canvas.height);
                console.log('VideoEditor duration:', videoEditor.duration);
                console.log('Video tracks:', videoEditor.videoTracks.length);
                console.log('Audio tracks:', videoEditor.audioTracks.length);

                // Validate canvas dimensions
                if (canvas.width === 0 || canvas.height === 0) {
                    throw new Error('Canvas has invalid dimensions: ' + canvas.width + 'x' + canvas.height);
                }

                // Validate main video element is loaded
                const mainVideoEl = document.getElementById('editor-video');
                if (!mainVideoEl) {
                    throw new Error('Main video element not found');
                }
                if (mainVideoEl.readyState < 2) { // HAVE_CURRENT_DATA
                    console.warn('Main video not fully loaded, readyState:', mainVideoEl.readyState);
                    loadingStatus.textContent = 'Waiting for video to load...';
                    await new Promise((resolve) => {
                        mainVideoEl.oncanplay = resolve;
                        // Timeout after 10 seconds
                        setTimeout(resolve, 10000);
                    });
                }
                console.log('Main video ready, readyState:', mainVideoEl.readyState);

                // Create MediaRecorder to capture canvas
                console.log('Creating canvas stream...');
                const stream = canvas.captureStream(30); // 30 fps
                console.log('Stream created:', stream);
                console.log('Stream tracks:', stream.getTracks().length);

                // Create audio context for mixing
                console.log('Creating AudioContext...');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('AudioContext state:', audioContext.state);

                // Resume AudioContext if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    console.log('Resuming suspended AudioContext...');
                    await audioContext.resume();
                    console.log('AudioContext resumed, state:', audioContext.state);
                }

                const audioDestination = audioContext.createMediaStreamDestination();

                // We'll mix audio from all sources
                const audioSources = [];

                // Add audio from all video tracks
                for (let track of videoEditor.videoTracks) {
                    const videoEl = track.type === 'main' ?
                        document.getElementById('editor-video') :
                        videoEditor.videoElements[track.id];

                    if (videoEl && videoEl.captureStream) {
                        try {
                            const vidStream = videoEl.captureStream();
                            const audioTrack = vidStream.getAudioTracks()[0];
                            if (audioTrack) {
                                const source = audioContext.createMediaStreamSource(new MediaStream([audioTrack]));
                                audioSources.push({ source, track, element: videoEl });
                            }
                        } catch (e) {
                            console.log('Could not capture audio from video:', e);
                        }
                    }
                }

                // Add audio from audio tracks
                for (let track of videoEditor.audioTracks) {
                    const audioEl = videoEditor.audioElements[track.id];
                    if (audioEl && audioEl.captureStream) {
                        try {
                            const audStream = audioEl.captureStream();
                            const audioTrack = audStream.getAudioTracks()[0];
                            if (audioTrack) {
                                const source = audioContext.createMediaStreamSource(new MediaStream([audioTrack]));
                                audioSources.push({ source, track, element: audioEl });
                            }
                        } catch (e) {
                            console.log('Could not capture audio:', e);
                        }
                    }
                }

                // Connect all audio sources to destination (mixing)
                audioSources.forEach(({ source }) => {
                    source.connect(audioDestination);
                });

                // Add mixed audio to stream
                console.log('Audio tracks available:', audioDestination.stream.getAudioTracks().length);
                if (audioDestination.stream.getAudioTracks().length > 0) {
                    stream.addTrack(audioDestination.stream.getAudioTracks()[0]);
                    console.log('Audio track added to stream');
                }

                // Check MediaRecorder support
                if (!window.MediaRecorder) {
                    throw new Error('MediaRecorder not supported in this browser');
                }

                // Check codec support
                const mimeType = 'video/webm;codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    console.warn('VP9 not supported, trying VP8...');
                    const fallbackMime = 'video/webm;codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(fallbackMime)) {
                        throw new Error('WebM recording not supported in this browser');
                    }
                }

                const chunks = [];
                console.log('Creating MediaRecorder...');
                const recorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000 // 5 Mbps
                });
                console.log('MediaRecorder created, state:', recorder.state);

                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                        console.log('Data chunk received:', e.data.size, 'bytes. Total chunks:', chunks.length);
                    }
                };

                recorder.onerror = (e) => {
                    console.error('MediaRecorder error:', e);
                    console.error('Recorder state at error:', recorder.state);
                };

                return new Promise((resolve, reject) => {
                    console.log('Setting up recorder callbacks...');

                    recorder.onstop = async () => {
                        console.log('Recorder stopped. Chunks collected:', chunks.length);

                        // Clean up audio context
                        audioContext.close();

                        if (chunks.length === 0) {
                            reject(new Error('No video data was recorded'));
                            return;
                        }

                        const blob = new Blob(chunks, { type: 'video/webm' });
                        console.log('Created blob:', blob.size, 'bytes');

                        resolve(blob);
                    };

                    recorder.onerror = (e) => {
                        console.error('Recorder error:', e);
                        audioContext.close();
                        reject(new Error('MediaRecorder error: ' + (e.error?.message || 'Unknown error')));
                    };

                    // Start recording
                    console.log('Starting recorder...');
                    try {
                        recorder.start(100);
                        console.log('Recorder started successfully, state:', recorder.state);
                    } catch (e) {
                        console.error('Failed to start recorder:', e);
                        reject(new Error('Failed to start recording: ' + e.message));
                        return;
                    }

                    // Play the video from start
                    // The video editor's update loop will handle switching between clips
                    console.log('Seeking to start and playing...');
                    videoEditor.seek(0);
                    videoEditor.play();
                    console.log('Video playing, isPlaying:', videoEditor.isPlaying);

                    // Calculate total duration
                    const totalDuration = videoEditor.duration;
                    let checkInterval;
                    let renderStartTime = Date.now();

                    // Monitor progress
                    checkInterval = setInterval(() => {
                        const elapsed = (Date.now() - renderStartTime) / 1000;
                        const progress = Math.min(Math.round((elapsed / totalDuration) * 100), 99);
                        loadingStatus.textContent = `Rendering... ${progress}% (${Math.round(elapsed)}s / ${Math.round(totalDuration)}s)`;

                        // Check if we've reached the end
                        if (videoEditor.currentTime >= totalDuration - 0.1 || !videoEditor.isPlaying) {
                            clearInterval(checkInterval);
                            loadingStatus.textContent = 'Finalizing...';

                            setTimeout(() => {
                                recorder.stop();
                                videoEditor.pause();
                                videoEditor.seek(0);
                            }, 500);
                        }
                    }, 500);

                    // Safety timeout (10 minutes)
                    setTimeout(() => {
                        if (recorder.state === 'recording') {
                            clearInterval(checkInterval);
                            recorder.stop();
                            videoEditor.pause();
                            reject(new Error('Rendering timeout'));
                        }
                    }, 600000);
                });

            } catch (error) {
                console.error('Error rendering video:', error);
                throw error;
            }
        }

        // Handle video editor export
        async function handleVideoEditorExport() {
            if (!videoEditor) return;

            try {
                const settings = await videoEditor.exportVideo();

                // Update text elements with edited timing
                textElements = settings.textElements;

                // Check if we need to render edits
                const hasEdits = textElements.length > 0 ||
                                settings.videoTracks.length > 1 ||
                                settings.audioTracks.length > 1 ||
                                settings.speed !== 1;

                if (hasEdits && isVideo) {
                    // Build list of what will be rendered
                    let renderList = [];
                    if (textElements.length > 0) renderList.push(` ${textElements.length} text overlay(s)`);
                    if (settings.videoTracks.length > 1) renderList.push(` ${settings.videoTracks.length} video clips spliced`);
                    if (settings.audioTracks.length > 0) renderList.push(` ${settings.audioTracks.length} audio track(s) mixed`);
                    if (settings.speed !== 1) renderList.push(` Speed: ${settings.speed}x`);

                    const renderText = `Apply all edits to video before posting?\n\nThis will render:\n${renderList.join('\n')}\n\nNote: Rendering takes as long as your video duration.\nClick OK to render, Cancel to keep original video.`;

                    console.log('Showing render confirmation dialog...');
                    const render = confirm(renderText);
                    console.log('User clicked:', render ? 'OK (will render)' : 'Cancel (skip render)');

                    if (render) {
                        console.log('Starting render process...');

                        // Show main loading overlay
                        const loadingOverlay = document.getElementById('loading-overlay');
                        const loadingStatus = document.getElementById('loading-status');
                        if (loadingOverlay && loadingStatus) {
                            console.log('Showing loading overlay...');
                            loadingOverlay.classList.add('active');
                            loadingStatus.textContent = 'Starting render...';
                            console.log('Loading overlay shown');
                        } else {
                            console.error('Loading overlay elements not found!', {
                                loadingOverlay: !!loadingOverlay,
                                loadingStatus: !!loadingStatus
                            });
                        }

                        try {
                            console.log('Attempting server-side rendering (faster)...');
                            let renderedBlob;

                            try {
                                // Try server-side rendering first (10-100x faster)
                                renderedBlob = await renderEditedVideoServer();
                                console.log(' Server-side rendering successful!');
                            } catch (serverError) {
                                console.warn(' Server rendering failed, falling back to browser rendering:', serverError);
                                console.log('Using browser-based rendering (slower)...');
                                // Fallback to browser rendering
                                renderedBlob = await renderEditedVideo();
                                console.log(' Browser rendering successful!');
                            }

                            if (!renderedBlob) {
                                throw new Error('Rendering returned no video data');
                            }

                            console.log('Render complete! Blob size:', renderedBlob.size);

                            // Replace the selected file with rendered version
                            const fileName = `edited_${Date.now()}.webm`;
                            window.renderedVideoFile = new File([renderedBlob], fileName, { type: 'video/webm' });

                            // Update the preview video to show rendered version
                            const previewVideo = document.getElementById('preview-video');
                            const previewMedia = document.getElementById('preview-media');
                            const previewCanvas = document.getElementById('preview-canvas');

                            console.log('Updating preview with rendered video...');
                            console.log('Preview elements found:', {
                                previewVideo: !!previewVideo,
                                previewMedia: !!previewMedia,
                                previewCanvas: !!previewCanvas
                            });

                            if (previewVideo) {
                                // Clean up old URL if exists
                                if (previewVideo.src) {
                                    URL.revokeObjectURL(previewVideo.src);
                                }

                                const renderedUrl = URL.createObjectURL(renderedBlob);
                                previewVideo.src = renderedUrl;
                                previewVideo.load();

                                // Hide other preview elements, show video
                                if (previewMedia) previewMedia.style.display = 'none';
                                if (previewCanvas) previewCanvas.style.display = 'none';
                                previewVideo.style.display = 'block';

                                console.log('Preview updated with rendered video:', renderedUrl);
                            } else {
                                console.error('preview-video element not found!');
                            }

                            // Update selectedFile reference
                            selectedFile = window.renderedVideoFile;
                            console.log('selectedFile updated to rendered video');

                            // Hide loading overlay
                            if (loadingOverlay) {
                                loadingOverlay.classList.remove('active');
                                console.log('Loading overlay hidden');
                            }

                            showToast(' Video rendered with all edits!', 'success', 4000);
                            console.log('Video rendered successfully:', {
                                videoTracks: settings.videoTracks.length,
                                audioTracks: settings.audioTracks.length,
                                textElements: textElements.length,
                                fileSize: `${(renderedBlob.size / (1024 * 1024)).toFixed(2)} MB`
                            });
                        } catch (error) {
                            console.error('Error rendering:', error);
                            console.error('Error stack:', error.stack);

                            // Hide loading overlay
                            if (loadingOverlay) {
                                loadingOverlay.classList.remove('active');
                                console.log('Loading overlay hidden');
                            }

                            showToast(' Failed to render edits', 'error');
                            alert('Failed to render video.\n\nError: ' + error.message + '\n\nCheck the console for details.');
                        }
                    } else {
                        console.log('User cancelled rendering');
                    }
                }

                // Store other settings
                window.videoEditorSettings = {
                    speed: settings.speed,
                    volume: settings.volume,
                    voiceoverTrack: settings.voiceoverTrack,
                    videoTracks: settings.videoTracks,
                    audioTracks: settings.audioTracks
                };

                // Redraw canvas with updated text elements
                drawCanvas();

                // Close the editor
                closeVideoEditor();

                console.log('Video editor settings applied:', settings);
            } catch (err) {
                console.error('Error exporting video:', err);
                alert('Error applying video edits');
            }
        }

        // Multi-track editor functions
        function triggerVideoUpload() {
            document.getElementById('video-clip-upload').click();
        }

        function triggerAudioUpload() {
            document.getElementById('audio-clip-upload').click();
        }

        function handleVideoClipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!videoEditor) {
                showToast(' Please open the video editor first', 'error');
                return;
            }

            showLoading('Adding video clip...');
            setTimeout(() => {
                videoEditor.addVideoClip(file);
                hideLoading();
                showToast(` ${file.name} added`, 'success');
                console.log('Added video clip:', file.name);
            }, 300);
        }

        function handleAudioClipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!videoEditor) {
                showToast(' Please open the video editor first', 'error');
                return;
            }

            showLoading('Adding audio track...');
            setTimeout(() => {
                videoEditor.addAudioClip(file);
                hideLoading();
                showToast(` ${file.name} added`, 'success');
                console.log('Added audio clip:', file.name);
            }, 300);
        }

        function openTextCreator() {
            if (!videoEditor) {
                showToast(' Please open the video editor first', 'error');
                return;
            }

            const content = prompt('Enter text content:');
            if (!content) return;

            videoEditor.addTextLayer({
                content: content,
                x: 540,
                y: 960,
                size: 48,
                color: 'white',
                font: 'Arial',
                style: 'outline',
                startTime: 0,
                endTime: Math.min(3, videoEditor.duration)
            });

            showToast(` "${content}" added`, 'success');
            console.log('Added text layer:', content);
        }

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.getElementById('editor-toast');
            if (!toast) return;

            toast.textContent = message;
            toast.className = 'editor-toast ' + type;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // Loading indicator functions
        function showLoading(text = 'Loading...') {
            const loading = document.getElementById('editor-loading');
            if (!loading) return;

            const loadingText = loading.querySelector('.editor-loading-text');
            if (loadingText) loadingText.textContent = text;

            loading.classList.add('show');
        }

        function hideLoading() {
            const loading = document.getElementById('editor-loading');
            if (!loading) return;

            loading.classList.remove('show');
        }

        // Show editor help
        function showEditorHelp() {
            const helpText = ` QUICK GUIDE 

 VIDEO CLIPS
 Tap + Video to add clips
 Drag clips to move them
 Pinch handles to resize

 AUDIO
 Tap + Audio for music
 Video audio shown automatically
 Mix multiple tracks

 TEXT
 Tap + Text to add
 Drag to reposition
 Edit timing on timeline

 TIPS
 Tap and hold clips to move
 Drag scrubber to preview
 Use two fingers for precision

Tap anywhere to close`;

            if (confirm(helpText)) {
                showToast(' Got it!', 'success');
            }
        }

        // Add toast notifications for common actions
        const originalAddVideoClip = window.videoEditor?.addVideoClip;
        if (window.videoEditor && originalAddVideoClip) {
            window.videoEditor.addVideoClip = function(...args) {
                showToast(' Video clip added', 'success');
                return originalAddVideoClip.apply(this, args);
            };
        }
    </script>

    <!-- Video Editor UI -->
    <div id="video-editor" class="video-editor">
        <div class="editor-header">
            <button class="editor-back-btn" onclick="closeVideoEditor()">
                <i class="bi bi-x"></i> Cancel
            </button>
            <span class="editor-title">
                Edit Video
                <button class="editor-help-btn" onclick="showEditorHelp()" title="Help">
                    <i class="bi bi-question-lg"></i>
                </button>
            </span>
            <button class="editor-done-btn" onclick="handleVideoEditorExport()">
                Done
            </button>
        </div>

        <!-- Toast Notification -->
        <div id="editor-toast" class="editor-toast"></div>

        <!-- Loading Indicator -->
        <div id="editor-loading" class="editor-loading">
            <div class="editor-loading-spinner"></div>
            <div class="editor-loading-text">Loading...</div>
        </div>

        <div class="editor-preview">
            <video id="editor-video" class="editor-video" playsinline></video>
            <canvas id="editor-canvas" class="editor-canvas"></canvas>
            <div class="editor-play-pause">
                <i class="bi bi-play-fill"></i>
            </div>
        </div>

        <div class="editor-timeline-container">
            <div class="timeline-controls">
                <button class="timeline-control-btn" onclick="openControlPanel('speed-panel')">
                    <i class="bi bi-speedometer2"></i> Speed
                </button>
                <button class="timeline-control-btn" onclick="openControlPanel('volume-panel')">
                    <i class="bi bi-volume-up"></i> Volume
                </button>
                <button class="timeline-control-btn" onclick="openControlPanel('voiceover-panel')">
                    <i class="bi bi-mic"></i> Voiceover
                </button>
                <button class="timeline-control-btn" onclick="openControlPanel('text-timing-panel')">
                    <i class="bi bi-clock"></i> Text Timing
                </button>
            </div>

            <div class="editor-timeline">
                <div class="timeline-time-display">
                    <span class="timeline-time">0:00</span>
                    <span class="timeline-duration">0:00</span>
                </div>

                <div class="timeline-scrubber-track">
                    <div class="timeline-thumbnails"></div>
                    <div class="timeline-scrubber">
                        <div class="timeline-playhead-time">0:00</div>
                    </div>
                </div>

                <!-- Add Buttons -->
                <div class="timeline-add-buttons">
                    <button class="timeline-add-btn" onclick="triggerVideoUpload()">
                        <i class="bi bi-film"></i> <span>+ Video</span>
                    </button>
                    <button class="timeline-add-btn" onclick="triggerAudioUpload()">
                        <i class="bi bi-music-note"></i> <span>+ Audio</span>
                    </button>
                    <button class="timeline-add-btn" onclick="openTextCreator()">
                        <i class="bi bi-fonts"></i> <span>+ Text</span>
                    </button>
                </div>

                <!-- Hidden file inputs -->
                <input type="file" id="video-clip-upload" accept="video/*" style="display: none" onchange="handleVideoClipUpload(event)">
                <input type="file" id="audio-clip-upload" accept="audio/*" style="display: none" onchange="handleAudioClipUpload(event)">

                <!-- Video Tracks Section -->
                <div class="timeline-section">
                    <div class="timeline-section-header">
                        <i class="bi bi-film"></i> Video Clips
                    </div>
                    <div id="video-tracks-container"></div>
                </div>

                <!-- Audio Tracks Section -->
                <div class="timeline-section">
                    <div class="timeline-section-header">
                        <i class="bi bi-music-note"></i> Audio Tracks
                    </div>
                    <div id="audio-tracks-container"></div>
                </div>

                <!-- Text Elements Section -->
                <div class="timeline-section">
                    <div class="timeline-section-header">
                        <i class="bi bi-fonts"></i> Text Elements
                    </div>
                    <div id="text-tracks-container"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="speed-panel" class="editor-control-panel">
        <div class="control-panel-header">
            <h3 class="control-panel-title">Playback Speed</h3>
            <button class="control-panel-close" onclick="closeControlPanel('speed-panel')">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="speed-options">
            <button class="speed-option" data-speed="0.3" onclick="videoEditor.setPlaybackSpeed(0.3)">0.3x</button>
            <button class="speed-option" data-speed="0.5" onclick="videoEditor.setPlaybackSpeed(0.5)">0.5x</button>
            <button class="speed-option selected" data-speed="1" onclick="videoEditor.setPlaybackSpeed(1)">1x</button>
            <button class="speed-option" data-speed="1.5" onclick="videoEditor.setPlaybackSpeed(1.5)">1.5x</button>
            <button class="speed-option" data-speed="2" onclick="videoEditor.setPlaybackSpeed(2)">2x</button>
            <button class="speed-option" data-speed="3" onclick="videoEditor.setPlaybackSpeed(3)">3x</button>
        </div>
    </div>

    <div id="volume-panel" class="editor-control-panel">
        <div class="control-panel-header">
            <h3 class="control-panel-title">Audio Volume</h3>
            <button class="control-panel-close" onclick="closeControlPanel('volume-panel')">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="volume-control">
            <div class="volume-label">
                <span class="volume-label-text">Original Audio</span>
                <span class="volume-value" id="video-volume-value">100%</span>
            </div>
            <input type="range" class="volume-slider" id="video-volume-slider" min="0" max="100" value="100" oninput="videoEditor.setVolume(this.value / 100)">
        </div>
        <div class="volume-control">
            <div class="volume-label">
                <span class="volume-label-text"><i class="bi bi-music-note"></i> Background Music</span>
                <span class="volume-value" id="music-volume-value">80%</span>
            </div>
            <input type="range" class="volume-slider" id="music-volume-slider" min="0" max="100" value="80">
        </div>
    </div>

    <div id="voiceover-panel" class="editor-control-panel">
        <div class="control-panel-header">
            <h3 class="control-panel-title">Voiceover</h3>
            <button class="control-panel-close" onclick="closeControlPanel('voiceover-panel')">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="voiceover-controls">
            <p style="color: rgba(255,255,255,0.7); font-size: 14px; margin-bottom: 16px;">
                Record audio over your video.
            </p>
            <button id="voiceover-record-btn" class="voiceover-record-btn" onclick="if(this.classList.contains('recording')) { videoEditor.stopVoiceoverRecording() } else { videoEditor.startVoiceoverRecording() }">
                <i class="bi bi-mic"></i> Start Recording
            </button>
            <div class="voiceover-waveform" id="voiceover-waveform">
                No voiceover recorded
            </div>
        </div>
    </div>

    <div id="text-timing-panel" class="editor-control-panel">
        <div class="control-panel-header">
            <h3 class="control-panel-title">Text Timing</h3>
            <button class="control-panel-close" onclick="closeControlPanel('text-timing-panel')">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <p style="color: rgba(255,255,255,0.7); font-size: 14px; margin-bottom: 16px;">
            Set when each text element appears and disappears. Drag the handles on the timeline.
        </p>
        <div class="text-timing-list" id="text-timing-list"></div>
    </div>

</body>
</html>
